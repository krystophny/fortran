program test_argument_matching
    use semantic_analyzer
    use type_checker
    use type_system_hm
    use ast_core
    implicit none

    integer :: test_count = 0
    integer :: pass_count = 0

    write (*, '(a)') '=== Testing Function Argument Type Matching ==='
    write (*, '(a)') ''

    call test_exact_match()
    call test_promotion_allowed()
    call test_arity_mismatch()
    call test_user_function_args()
    call test_multiple_arguments()

    write (*, '(a)') ''
    write(*, '(a,i0,a,i0,a)') 'Argument matching tests: ', pass_count, '/', test_count, ' passed'

    if (pass_count /= test_count) then
        error stop 'Some tests failed!'
    end if

contains

    subroutine test_exact_match()
        type(mono_type_t) :: arg_types(1), param_types(1)
        type(mono_type_t) :: int_type, real_type
        logical :: match

        write (*, '(a)') 'Test 1: Exact type match'
        test_count = test_count + 1

        ! Create types
        int_type = create_mono_type(TINT)
        real_type = create_mono_type(TREAL)

        ! Test exact match
        arg_types(1) = int_type
        param_types(1) = int_type

        match = check_argument_types(arg_types, param_types, .false.)

        if (match) then
            pass_count = pass_count + 1
            write (*, '(a)') '  ✓ PASS: Exact type match works'
        else
            write (*, '(a)') '  ✗ FAIL: Exact match failed'
        end if

    end subroutine test_exact_match

    subroutine test_promotion_allowed()
        type(mono_type_t) :: arg_types(1), param_types(1)
        type(mono_type_t) :: int_type, real_type
        logical :: match

        write (*, '(a)') 'Test 2: Type promotion in arguments'
        test_count = test_count + 1

        ! Create types
        int_type = create_mono_type(TINT)
        real_type = create_mono_type(TREAL)

        ! Test promotion: passing int to real parameter
        arg_types(1) = int_type
        param_types(1) = real_type

        ! Without promotion - should fail
        match = check_argument_types(arg_types, param_types, .false.)

        if (.not. match) then
            ! With promotion - should succeed
            match = check_argument_types(arg_types, param_types, .true.)

            if (match) then
                pass_count = pass_count + 1
                write (*, '(a)') '  ✓ PASS: Type promotion works when allowed'
            else
                write (*, '(a)') '  ✗ FAIL: Type promotion failed'
            end if
        else
            write (*, '(a)') '  ✗ FAIL: Promotion occurred when not allowed'
        end if

    end subroutine test_promotion_allowed

    subroutine test_arity_mismatch()
        type(mono_type_t) :: arg_types(2), param_types(1)
        type(mono_type_t) :: int_type
        logical :: match

        write (*, '(a)') 'Test 3: Arity mismatch detection'
        test_count = test_count + 1

        int_type = create_mono_type(TINT)

        ! Different number of arguments
        arg_types = int_type
        param_types(1) = int_type

        match = check_argument_types(arg_types, param_types, .true.)

        if (.not. match) then
            pass_count = pass_count + 1
            write (*, '(a)') '  ✓ PASS: Arity mismatch properly detected'
        else
            write (*, '(a)') '  ✗ FAIL: Arity mismatch not detected'
        end if

    end subroutine test_arity_mismatch

    subroutine test_user_function_args()
        type(semantic_context_t) :: ctx
        type(function_def_node) :: func
        type(function_call_node) :: call1, call2
        type(identifier_node) :: param1, param2, func_name
        type(literal_node) :: int_arg, real_arg
        type(assignment_node) :: assign
        type(ast_node_wrapper) :: param_wrapper1, param_wrapper2, body_wrapper
        type(ast_node_wrapper) :: arg_wrapper1, arg_wrapper2
        type(mono_type_t) :: typ

        write (*, '(a)') 'Test 4: User function argument checking'
        test_count = test_count + 1

        ctx = create_semantic_context()

        ! Define function: function add(x, y) with integer parameters
        param1 = create_identifier("x", 1, 14)
        param2 = create_identifier("y", 1, 17)
        allocate (param_wrapper1%node, source=param1)
        allocate (param_wrapper2%node, source=param2)

        ! Dummy body
        int_arg = create_literal("0", LITERAL_INTEGER, 2, 5)
        allocate (body_wrapper%node, source=int_arg)

        func = create_function_def("add", [param_wrapper1, param_wrapper2], &
                               create_identifier("integer", 1, 1), [body_wrapper], 1, 1)

        ! Analyze function definition
        typ = ctx%analyze_function_def(func)

        ! Call with correct types: add(1, 2)
        int_arg = create_literal("1", LITERAL_INTEGER, 3, 5)
        allocate (arg_wrapper1%node, source=int_arg)
        int_arg = create_literal("2", LITERAL_INTEGER, 3, 8)
        allocate (arg_wrapper2%node, source=int_arg)

        call1 = create_function_call("add", [arg_wrapper1, arg_wrapper2], 3, 1)
        func_name = create_identifier("r1", 3, 1)
        assign = create_assignment(func_name, call1, 3, 1)

        ! This should succeed
        typ = ctx%infer_stmt(assign)

        ! For now, just check that inference completes
        pass_count = pass_count + 1
        write (*, '(a)') '  ✓ PASS: User function argument inference works'

    end subroutine test_user_function_args

    subroutine test_multiple_arguments()
        type(mono_type_t) :: arg_types(3), param_types(3)
        type(mono_type_t) :: int_type, real_type, char_type
        logical :: match

        write (*, '(a)') 'Test 5: Multiple argument matching'
        test_count = test_count + 1

        ! Create types
        int_type = create_mono_type(TINT)
        real_type = create_mono_type(TREAL)
        char_type = create_mono_type(TCHAR, char_size=10)

        ! Set up parameter types: (int, real, char)
        param_types(1) = int_type
        param_types(2) = real_type
        param_types(3) = char_type

        ! Test 1: Exact match
        arg_types = param_types
        match = check_argument_types(arg_types, param_types, .false.)

        if (match) then
            ! Test 2: One wrong type
            arg_types(2) = int_type  ! Wrong type in middle
            match = check_argument_types(arg_types, param_types, .false.)

            if (.not. match) then
                ! Test 3: With promotion it should work
                match = check_argument_types(arg_types, param_types, .true.)

                if (match) then
                    pass_count = pass_count + 1
                 write (*, '(a)') '  ✓ PASS: Multiple argument matching works correctly'
                else
                    write (*, '(a)') '  ✗ FAIL: Promotion should allow int->real'
                end if
            else
                write (*, '(a)') '  ✗ FAIL: Type mismatch not detected'
            end if
        else
            write (*, '(a)') '  ✗ FAIL: Exact match failed'
        end if

    end subroutine test_multiple_arguments

end program test_argument_matching
