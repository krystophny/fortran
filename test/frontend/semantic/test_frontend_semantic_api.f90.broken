program test_frontend_semantic_api
    use semantic_analyzer, only: analyze_program, create_semantic_context, semantic_context_t
    use ast_core
    use ast_factory, only: push_program, push_assignment, push_identifier, push_literal, push_binary_op
    use lexer_core, only: tokenize_core, token_t
    use parser_state_module, only: parser_state_t, create_parser_state
    use parser_dispatcher_module, only: parse_statement_dispatcher
    implicit none

    logical :: all_passed

    all_passed = .true.

    print *, '=== Semantic Analyzer API Unit Tests ==='
    print *

    ! Test individual semantic analysis features via API
    if (.not. test_assignment_analysis()) all_passed = .false.
    if (.not. test_type_inference()) all_passed = .false.
    if (.not. test_variable_analysis()) all_passed = .false.
    if (.not. test_expression_analysis()) all_passed = .false.
    if (.not. test_error_detection()) all_passed = .false.

    ! Report results
    print *
    if (all_passed) then
        print *, 'All semantic analyzer API tests passed!'
        stop 0
    else
        print *, 'Some semantic analyzer API tests failed!'
        stop 1
    end if

contains

    logical function test_assignment_analysis()
        test_assignment_analysis = .true.
        print *, 'Testing assignment analysis...'

        block
            type(ast_arena_t) :: arena
            type(semantic_context_t) :: ctx
            integer :: prog_index, stmt_index
            integer :: target_index, value_index
            integer :: body_indices(1)
            
            ! Create arena and AST manually
            arena = create_ast_stack()
            
            ! Create assignment: x = 42
            ! Create identifier node for 'x'
            target_index = push_identifier(arena, 'x', 2, 1)
            
            ! Create literal node for '42'
            value_index = push_literal(arena, '42', LITERAL_INTEGER, 2, 5)
            
            ! Create assignment node
            stmt_index = push_assignment(arena, target_index, value_index, 2, 1)
            
            ! Create program node with the assignment as body
            body_indices(1) = stmt_index
            prog_index = push_program(arena, 'test_assign', body_indices, 1, 1)
            
            if (prog_index > 0) then
                ctx = create_semantic_context()
                call analyze_program(ctx, arena, prog_index)
                print *, '  PASS: Assignment analysis'
            else
                print *, '  FAIL: Could not create AST'
                test_assignment_analysis = .false.
            end if
        end block

    end function test_assignment_analysis

    logical function test_type_inference()
        test_type_inference = .true.
        print *, 'Testing type inference...'

        block
            type(ast_arena_t) :: arena
            type(semantic_context_t) :: ctx
            integer :: prog_index, stmt_index
            integer :: target_index, value_index
            integer :: body_indices(1)
            
            ! Create arena and AST manually
            arena = create_ast_stack()
            
            ! Create assignment: pi = 3.14
            ! Create identifier node for 'pi'
            target_index = push_identifier(arena, 'pi', 2, 1)
            
            ! Create literal node for '3.14'
            value_index = push_literal(arena, '3.14', LITERAL_REAL, 2, 6)
            
            ! Create assignment node
            stmt_index = push_assignment(arena, target_index, value_index, 2, 1)
            
            ! Create program node with the assignment as body
            body_indices(1) = stmt_index
            prog_index = push_program(arena, 'test_inference', body_indices, 1, 1)
            
            if (prog_index > 0) then
                ctx = create_semantic_context()
                call analyze_program(ctx, arena, prog_index)
                
                ! Check if type inference was performed on the assignment
                if (stmt_index > 0 .and. stmt_index <= arena%size) then
                    select type (stmt => arena%entries(stmt_index)%node)
                    type is (assignment_node)
                        if (allocated(stmt%inferred_type)) then
                            print *, '  PASS: Type inference performed'
                        else
                            print *, '  WARN: Type inference not performed'
                        end if
                    class default
                        print *, '  WARN: Unexpected statement type'
                    end select
                else
                    print *, '  FAIL: Invalid statement index'
                    test_type_inference = .false.
                end if
            else
                print *, '  FAIL: Could not create AST'
                test_type_inference = .false.
            end if
        end block

    end function test_type_inference

    logical function test_variable_analysis()
        test_variable_analysis = .true.
        print *, 'Testing variable analysis...'

        block
            type(ast_arena_t) :: arena
            type(semantic_context_t) :: ctx
            integer :: prog_index, stmt1_index, stmt2_index
            integer :: target1_index, value1_index
            integer :: target2_index, value2_index
            integer :: body_indices(2)
            
            ! Create arena and AST manually
            arena = create_ast_stack()
            
            ! First assignment: x = 1
            target1_index = push_identifier(arena, 'x', 2, 1)
            value1_index = push_literal(arena, '1', LITERAL_INTEGER, 2, 5)
            stmt1_index = push_assignment(arena, target1_index, value1_index, 2, 1)
            
            ! Second assignment: y = x
            target2_index = push_identifier(arena, 'y', 3, 1)
            value2_index = push_identifier(arena, 'x', 3, 5)
            stmt2_index = push_assignment(arena, target2_index, value2_index, 3, 1)
            
            ! Create program node with both assignments
            body_indices(1) = stmt1_index
            body_indices(2) = stmt2_index
            prog_index = push_program(arena, 'test_vars', body_indices, 1, 1)
            
            if (prog_index > 0) then
                ctx = create_semantic_context()
                call analyze_program(ctx, arena, prog_index)
                print *, '  PASS: Variable analysis'
            else
                print *, '  FAIL: Could not create AST'
                test_variable_analysis = .false.
            end if
        end block

    end function test_variable_analysis

    logical function test_expression_analysis()
        test_expression_analysis = .true.
        print *, 'Testing expression analysis...'

        block
            type(ast_arena_t) :: arena
            type(semantic_context_t) :: ctx
            integer :: prog_index, stmt_index
            integer :: target_index, binop_index
            integer :: left_index, right_index
            integer :: body_indices(1)
            
            ! Create arena and AST manually
            arena = create_ast_stack()
            
            ! Create assignment with binary operation: result = a + b
            target_index = push_identifier(arena, 'result', 2, 1)
            
            ! Create binary operation: a + b
            left_index = push_identifier(arena, 'a', 2, 10)
            right_index = push_identifier(arena, 'b', 2, 14)
            binop_index = push_binary_op(arena, '+', left_index, right_index, 2, 12)
            
            ! Create assignment node
            stmt_index = push_assignment(arena, target_index, binop_index, 2, 1)
            
            ! Create program node
            body_indices(1) = stmt_index
            prog_index = push_program(arena, 'test_expr', body_indices, 1, 1)
            
            if (prog_index > 0) then
                ctx = create_semantic_context()
                call analyze_program(ctx, arena, prog_index)
                print *, '  PASS: Expression analysis'
            else
                print *, '  FAIL: Could not create AST'
                test_expression_analysis = .false.
            end if
        end block

    end function test_expression_analysis

    logical function test_error_detection()
        test_error_detection = .true.
        print *, 'Testing error detection...'

        block
            type(ast_arena_t) :: arena
            type(semantic_context_t) :: ctx
            integer :: prog_index, stmt_index
            integer :: target_index, value_index
            integer :: body_indices(1)
            
            ! Create arena and AST manually
            arena = create_ast_stack()
            
            ! Create assignment with undefined variable: result = undefined_var
            target_index = push_identifier(arena, 'result', 2, 1)
            value_index = push_identifier(arena, 'undefined_var', 2, 10)
            stmt_index = push_assignment(arena, target_index, value_index, 2, 1)
            
            ! Create program node
            body_indices(1) = stmt_index
            prog_index = push_program(arena, 'test_error', body_indices, 1, 1)
            
            if (prog_index > 0) then
                ctx = create_semantic_context()
                call analyze_program(ctx, arena, prog_index)
                print *, '  PASS: Error detection test completed'
            else
                print *, '  FAIL: Could not create AST'
                test_error_detection = .false.
            end if
        end block

    end function test_error_detection

end program test_frontend_semantic_api
